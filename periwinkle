#!/usr/bin/fish

#    Periwinkle - A MPD client with tight integration with dmenu and libnotify.
#    Copyright (C) 2023 Fen
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

# -------------------
# CONFIGURATION STUFF
# -------------------


# Here's the config for Periwinkle
# You'll have to change this before you do anything else

# ---
# MPD
# ---
#
# Choose where to point

#set -g MPD_Host localhost
#set -g MPD_Port 6600

# Choose your music directory

#set -g Directory_MusicFolder "$HOME/Music"

# -----
# DMENU
# -----
#
# In dwm, usually the following equivalents for dmenu coloring are:
# Bar_Font = dmenufont
# Color_Background = col_gray1
# Color_Foreground = col_gray3
# Color_SelectedBackground = col_gray4
# Color_SelectedForeground = col_cyan

#set -g Bar_Font "Sans Serif:size=10"
#set -g Color_Background "#5B544C"
#set -g Color_Foreground "#E4E3E0"
#set -g Color_SelectedBackground "#DA2A47"
#set -g Color_SelectedForeground "#E4E3E0"

# Location of DMENU, if it's at the bottom or top.
# By default it's at the bottom

#set -g Bar_Position bottom

# ----------------
# PREVIEW SETTINGS
# ----------------
#
# Choose where to save the image previews

#set -g Directory_AlbumCover "$HOME/periwinkle"

# ---------------------
# NOTIFICATION SETTINGS
# ---------------------
#
# Notify timeout in seconds
# Set 0 for no timeout

#set -g Notify_Timeout 5

# Show extra control buttons in the popup

#set -g Notify_ExtraButtons false

# Format the notification
# Set the appearance of the notification to your liking.
# Side note: %datep% is a variant of %date%, what it does is that if the metadata doesn't contain any date, it hides the parenthesis. Otherwise, if it contains a year, it shows them.

#set -g Notify_TitlePlay "%stateicon% %title%"
#set -g Notify_SubtitlePlay "%artist%\n%album% %datep%"

# Set the title to appear when the queue is completely stopped

#set Notify_TitleStop "%stateicon% Stopped"

# Use formatting behavior from CLI, similar to previous versions of Periwinkle
# So what this does is basically when a song has no title, it displays the filename instead. And if there's no artist, it shows "Unknown Artist"
# By default, it's set on "false"

#set -g Notify_FillEmptyTags false

# ----------------
# PREVIEW SETTINGS
# ----------------
# 
# Choose the hash that you would like to use to save the image previews
# This is useful to keep every single album unique.
# For example, if you had Weezer self-titled albums with the same album name in their metadata, it should be able to differentiate them to show the correct album cover because they have a different metadata for the year and artist. If you have proper metadata for every album then it should work as expected
#
# Options: 
# none | md5 | sha256 | sha512 | base64
# The default is sha256

#set -g UseHash "sha256"

# Down here is code!

function pw_Help
	echo "Periwinkle - The cutest MPD client
Fish shell edition

	This is a CLI and also a semi-GUI client that can
	be integrated into a DWM desktop by the use of
	dunst and dmenu, if you'd like.

	Usage: periwinkle [<command> <arguments> ... <more args>]

	Fetch Commands
		add <file> - Adds a song from the music dir to the playlist
		delete <int song> - Removes a song from the playlist
		list <metadata arg1> [<metadata arg2> <search term>] - Fetches a list of songs based on the metadata input by the user

	Playback Commands
		pause - Toggles between pause and play
		play - Play the current song
		stop - Stops the playlist completely
		prev, previous - Goes to the previous song on the queue
		next, forward - Goes to the next song on the queue
		setvol <0 - 100> - Sets the volume
		seek <num> - Seeks to a certain point of the song
		single <0-1 or oneshot> - Sets single mode
		random <0-1> - Sets random mode
		repeat <0-1> - Sets repeat mode
		consume <0-1> - Sets consume mode

	Playlist Commands
		crossfade <int> - Sets a crossfade between songs
		shuffle - Shuffles the playlist
		save <string playlist name> - Saves the playlist as a file
		rm <string playlist name> - Deletes a saved playlist
		playlist - Shows the current playlist and song IDs
		delete - Removes a song from the current playlist

	Database Commands
		update - Updates the MPD database

	Periwinkle Commands
		menu - Shows the dmenu prompt directly
		info - Report version of Periwinkle, and licensing information
		print <%title% %artist% %album% %date% %datep% %songid% %state% %stateicon%> - Command that works like mpc's --format flag.
		The point of the command above is to echo current song info in a clean manner for other scripts.

	Dmenu Exclusive Commands
		cli <cmd> - Runs a CLI command within dmenu

	Advanced Commands
		statsfornerds - Shows some environment variables related to Periwinkle
		console - Pulls an interactive MPD control terminal (advanced)
		direct - Sends commands to MPD without going into the interactive terminal

	If you want to change the settings for this client, tinker with the periwinkle script.
	All documentation is on the script."
end

function pw_AboutProgram
echo "
    Periwinkle - The cutest MPD client
    Version:

    Copyright (C) 2023 Fen

    Contributors: ChatGPT, Barrucadu

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>."
end

function pw_Error
	switch $argv[1]
    case UnknownCommand
			echo 'Error: "'"$argv[2]"'" is not a known command >.<'
			exit 1
	
    case InvalidInteger
			echo 'Error: "'"$argv[2]"'" is not a valid integer -w-'
			exit 1

    case InvalidNumber
			echo 'Error: "'"$argv[2]"'" is not a valid number -w-'
			exit 1

    case FewArguments
			echo "Error: Not enough arguments... ;w;"
			exit 1

    case ManyArguments
			echo "Error: T-That's too many arguments!! >w<"
			exit 1

    case WrongArguments
			echo "Error: Wrong arguments for this command... :<"
			exit 1

    case PlaylistClear
			echo 'Error: You can'"'"'t "'"$argv[2]"'" if you have no songs in your queue or if the queue is stopped! >:3'
			exit 1

    case '*'
			echo "Error: Something went wrong... o.O
			If you see this error please open a issue report about it"
			exit 1
  end
end

# Check if the necessary dependencies are installed
function pw_MissingDependency
	switch $cmd
    case notify-send
			echo "Dependency missing: 'notify-send' (libnotify) is required but not found. Please install it."
			exit 1

    case nc
			echo "Dependency missing: 'nc' (openbsd-netcat or gnu-netcat) is required but not found. Please install it."
			exit 1

    case '*'
			echo 'Dependency missing: '"'$cmd'"' is required but not found. Please install it.'
			exit 1
  end
end

# Placeholder default check. Will be more sophisticated in the future.
function pw_FillInTheBlanks

	if [ -z "$MPD_Host" ]
		set -g MPD_Host "localhost"
  end
	
	if [ -z "$MPD_Port" ]
		set -g MPD_Port 6600
  end

	if [ -z "$Notify_Timeout" ]
		set -g Notify_Timeout 5	
  end

	if [ -z "$Notify_TitlePlay" ]
		set -g Notify_TitlePlay '%stateicon% "%title%"'
  end

	if [ -z "$Notify_SubtitlePlay" ]
		set -g Notify_SubtitlePlay "by %artist%\nfrom %album% %datep%"	
  end

	if [ -z "$Notify_TitleStop" ]
		set -g Notify_TitleStop "%stateicon% Stopped"
  end

	if [ -z "$Notify_FillEmptyTags" ]
		set -g Notify_FillEmptyTags false	
  end

	if [ -z "$Notify_ExtraButtons" ]
		set -g Notify_ExtraButtons false
  end

	if [ -z "$Bar_Position" ]
		set -g Bar_Position top
  end

	if [ -z "$Bar_Font" ]
		set -g Bar_Font "Sans Serif:size=10"
  end
	
	if [ -z "$Color_Background" ]
		set -g Color_Background "#C0C0C0"
  end

	if [ -z "$Color_Foreground" ]
		set -g Color_Foreground "#000000"
  end

	if [ -z "$Color_SelectedBackground" ]
    set -g Color_SelectedBackground "#000080"
  end

	if [ -z "$Color_SelectedForeground" ]
		set -g Color_SelectedForeground "#FFFFFF"
  end

	if [ -z "$Directory_AlbumCover" ]
		set -g Directory_AlbumCover "$HOME/periwinkle"
  end

	if [ -z "$Directory_MusicFolder" ]
		set -g Directory_MusicFolder "$HOME/Music"
  end
end

# Function to check if a value is a number
function pw_isPositiveNumber
	if [ "$argv[1]" -gt 0 ]
		return 0 # It's a positive number
	else
		return 1 # It's not a positive number or it contains non-numeric characters
  end
end

# Function to check if the integer is within the desired range
function pw_isNumberInRange
	if test "$argv[1]" -gt "$argv[2]" && test "$argv[1]" -lt "$argv[3]"
		return 0
	else
		return 1
  end
end

function pw_CheckNumber
  # Read input and validate it until a valid integer in the range is provided
	switch "$argv[1]"
    case "inRange"
			if ! pw_isNumberInRange "$argv[2]" "$argv[3]" "$argv[4]"
				# Set the variable with the validated integer
				pw_Error InvalidInteger "$argv[2]"
      end

    case "isPositive"
			if ! pw_isPositiveNumber "$argv[2]"
				pw_Error InvalidNumber "$argv[2]"
      end

    case '*'
			echo "$argv[2]"
			echo "DEBUG INFO: Invalid arguments for this function"
			echo "If you see this message, please open a issue about it."
			pw_Error
  end
end

function pw_SpawnNotification
	if [ -z "$OPPSTATUS" ] && [ "$NEWNOTIFBEHAVIOR" = 1 ]
		set -g NOTIFICATIONACTION ""
  else if [ "$NEWNOTIFBEHAVIOR" = 0 ]
		pw_Refresh
		set -g NOTIFICATIONACTION "--action ""$OPPSTATUS"="$OPPSTATUS"" --action forward="	
  end

	if [ -z "$mpc_file" ]
		set Notify_TitlePlay "$Notify_TitleStop"
		set Notify_SubtitlePlay ""
  end
	
	switch $argv[1]
    case action
			if [ -z "$NOTIFICATIONACTION" ]					
				set -g CONDITIONOPEN $(notify-send -t "$Notify_Timeout" -u low -r 27072 "$(pw_Print "$Notify_TitlePlay")" "$(pw_Print "$Notify_SubtitlePlay")" -i "$previewname" --action open=Show)
			else
				set -g CONDITIONOPEN $(notify-send -t "$Notify_Timeout" -u low -r 27072 "$(pw_Print "$Notify_TitlePlay")" "$(pw_Print "$Notify_SubtitlePlay")" -i "$previewname" --action open=Show "$NOTIFICATIONACTION")
      end

			if [ -z "$CONDITIONOPEN" ]
				return 0 
      else if [ "$CONDITIONOPEN" = "$OPPSTATUS" ] || [ "$CONDITIONOPEN" = "forward" ]
				pw_UserSelection "$OPPSTATUS"
				return 0
			else
				pw_MenuOptions "$CONDITIONOPEN"
      end

    case '*'
			notify-send -t '"'"$Notify_Timeout"'"' -u low -r 27072 '"'"$(pw_Print "$Notify_TitlePlay")"'"' '"'"$(pw_Print '"'"$Notify_SubtitlePlay")"'"' -i '"'"$previewname"'"'
  end
end

# Clean the stinky output
function pw_CleanOutput
	awk '!/^OK.*$/'
end

# Function to send commands to MPD which is netcat-agnostic
function pw_MPDCommand
  printf "%s\n" "$argv[1]" "close" | nc "$MPD_Host" "$MPD_Port"
end

function pw_ReloadMetadata

	switch $argv[1]
    case Title
			set -g title "$(echo "$stats" | awk -F ': ' '/^Title:/ { sub(/^Title: /, ""); print }')"
			set -g titlesave "$title"

			if [ -z "$title" ]
				set -g title "$mpc_file"
      end

    case Artist
			set -g artist "$(echo "$stats" | awk -F ': ' '/^Artist:/ { sub(/^Artist: /, ""); print }')"
			set -g artistsave "$artist"

			if [ -z "$artist" ]
				set -g artist "Unknown Artist"
      end

    case Album
			set -g album "$(echo "$stats" | awk -F ': ' '/^Album:/ { sub(/^Album: /, ""); print }')"

    case Date
			set -g date "$(echo "$stats" | awk -F ': ' '/^Date:/ { sub(/^Date: /, ""); print }')"
			set -g unprocesseddate $date
		
			if [ -z "$date" ]
				set -g date ""
			else
    		set -g date "($date)"
      end

    case SongId
			set -g songid "$(echo "$stats2" | awk -F ': ' '/^song:/ { sub(/^song: /, ""); print }')"

    case State
			set -g state "$(echo "$stats2" | awk -F ': ' '/^state:/ { sub(/^state: /, ""); print }')"
			if [ "$state" = "stop" ]
				set -g NOTIFYSEND_STATUS ""
				set -g OPPSTATUS ""
				set -g OPPSTATUS2 ""
      else if [ "$state" = "pause" ]
				set -g NOTIFYSEND_STATUS ""
				set -g OPPSTATUS ""
				set -g OPPSTATUS2 ""
      else if [ "$state" = "play" ]
				set -g NOTIFYSEND_STATUS ""
				set -g OPPSTATUS ""
				set -g OPPSTATUS2 ""
      end

    case RefreshVariables
			set -g stats "$(pw_MPDCommand currentsong | tr -d '\r')"
			set -g stats2 "$(pw_MPDCommand status | tr -d '\r')"
			set -g mpc_file "$(echo "$stats" | awk -F ': ' '/^file:/ {print $2}' | awk '{$1=$1};1')"
			set -g filename "$Directory_MusicFolder"'/'"$mpc_file";;

    case SetAlbumCover
			switch $UseHash
        case none
					set -g previewname "$Directory_AlbumCover"/"$album $date.png";;
        case md5
					set -g previewname "$Directory_AlbumCover"/"$(echo "$album $date" | md5sum | cut -d' ' -f1)"'.png'
        case base64
					set -g previewname "$Directory_AlbumCover"/"$(echo "$album $date" | base64 | cut -d' ' -f1)"'.png'
        case sha512
					set -g previewname "$Directory_AlbumCover"/"$(echo "$album $date" | sha512sum | cut -d' ' -f1)"'.png'
        case sha256 '*'
					set -g previewname "$Directory_AlbumCover"/"$(echo "$album $date" | sha256sum | cut -d' ' -f1)"'.png'	
      end

			[ -e "$previewname" ] || 
			ffmpeg -y -i "$filename" -an -vf scale=128:128 "$previewname" > /dev/null 2>&1

    case All
			pw_ReloadMetadata RefreshVariables
      pw_ReloadMetadata State
			pw_ReloadMetadata Title
			pw_ReloadMetadata Artist
			pw_ReloadMetadata Album
			pw_ReloadMetadata Date
			pw_ReloadMetadata SongId
			pw_ReloadMetadata SetAlbumCover
  end

	return 
end

function pw_Refresh
	pw_ReloadMetadata RefreshVariables
	pw_ReloadMetadata State

	if [ "$CurrentState" != "$state" ] || [ -z "$CurrentState" ]
		pw_ReloadMetadata State
		set CurrentState $state
	end

	if [ "$mpc_file" != "$CurrentFile" ] || [ -z "$CurrentFile" ]

		# Every attribute changes except for the title, it is unknown what causes this bug
		# So in the meantime, this is here until a fix is found for this
		# Feel free to experiment
	
		# My theory is that it's because of race conditions... yet again
		# This program has a lot of fucking issues with race conditions

		pw_ReloadMetadata Title
		pw_ReloadMetadata Date

		if [ "$CurrentTitle" != "$title" ] || [ -z "$CurrentTitle" ]	
			pw_ReloadMetadata Title
			set -g CurrentTitle $title
    end

		if [ "$CurrentArtist" != "$artist" ] || [ -z "$CurrentArtist" ]
			pw_ReloadMetadata Artist
			set -g CurrentArtist $artist
    end

		if [ "$CurrentAlbum" != "$album" ] || [ -z "$CurrentAlbum" ]
			pw_ReloadMetadata Album
			set -g CurrentArtist $album
    end

		if [ "$CurrentDate" != "$date" ] || [ -z "$CurrentDate" ]
			pw_ReloadMetadata Date
			set -g CurrentDate $date
    end

		if [ "$CurrentSongId" != "$songid" ] || [ -z "$CurrentSongId" ]
			pw_ReloadMetadata SongId
			set -g CurrentSongId $songid
    end

		pw_ReloadMetadata SetAlbumCover
		set -g CurrentFile "$mpc_file"

  end 

	return 0
end

function pw_SpawnMenu
	# echo "$Bar_Position" "$DMENU_TITLE" "$Bar_Font" "$Color_Background" "$Color_Foreground" "$Color_SelectedBackground" "$Color_SelectedForeground"

	dmenu "$Bar_Position" -i -p "$argv" -fn "$Bar_Font" -nb "$Color_Background" -nf "$Color_Foreground" -sb "$Color_SelectedBackground" -sf "$Color_SelectedForeground"
	return 0
end

function pw_MPDCommandButFiltered

    set arglist $argv[1]
     
    [ "$argv[2]" != "" ] &&                   set arglist "$arglist "$argv[2]""
    
    [ "$argv[3]" != "" ] && [ "$argv[4]" = "" ]  && set arglist "$arglist \"$argv[3]\""
    
    [ "$argv[3]" != "" ] && [ "$argv[4]" != "" ] && set arglist "$arglist $argv[3] \"$argv[4]\""

    [ "$argv[1]" = "add" ] || [ "$argv[1]" = "save" ] || [ "$argv[1]" = "rm" ] && set arglist "$argv[1] \"$argv[2]\""
    
    pw_MPDCommand "$arglist" | pw_CleanOutput
end

function pw_UserSelection 

	# Execute the desired action
	switch $argv[1]
    case  prev previous backward
			pw_MPDCommand previous > /dev/null 2>&1	
      
    case  pause
			pw_MPDCommand pause > /dev/null 2>&1	

    case  play
			pw_MPDCommand play > /dev/null 2>&1

    case  stop
			pw_MPDCommand stop > /dev/null 2>&1

    case  next forward
			pw_MPDCommand next > /dev/null 2>&1
			
    case seek volume setvol vol crossfade
			pw_MenuOptions integer "$argv[1]"

    case single random repeat consume
      pw_MenuOptions boolean "$argv[1]"

    case clear
			pw_MenuOptions clear

    case update shuffle
			pw_CLICommand "$argv[1]"

    case '*'
			pw_MenuOptions $argv[1]

  end
end

function pw_MenuOptions
	sleep 0.1
	pw_Refresh
	switch $argv[1]

    # Different commands
    case integer
			switch $argv[2]
        case setvol Setvol vol Vol volume
					set DMENU_TITLE 'Set volume (0-100)'
					set SELECTED "setvol"

        case seek Seek
					set DMENU_TITLE 'Seek to where?'
					set SELECTED "seek"

        case crossfade
					set DMENU_TITLE 'Set crossfade:'
					set SELECTED "crossfade"
      end

			set prompt "$(printf '%s\n' "Cancel" | pw_SpawnMenu $DMENU_TITLE)"

			if [ "$prompt" = "Cancel" ] || [ -z "$prompt" ]
				pw_CLICommand menu
				return 0
      else
			  pw_CLICommand "$SELECTED" "$prompt"
			  return 0
      end
    
    case boolean
			switch $argv[2]
        case single
					set mpd "0:1:oneshot"
        case '*'
					set mpd "0:1"
      end

			
			set DMENU_TITLE "Set boolean for $argv[2]"
			set prompt "$(printf '%s\n' "$mpd" | tr ':' '\n' | pw_SpawnMenu $DMENU_TITLE)"

			if [ -z "$prompt" ]
				pw_CLICommand menu
				return 0
      end
			pw_CLICommand "$argv[2]" "$prompt"

    case clear		
      set mpd "Yes:No"
      set DMENU_TITLE "Are you sure you want to clear the playlist?"
			set prompt "$(printf '%s\n' "$mpd" | tr ':' '\n' | pw_SpawnMenu $DMENU_TITLE)"

			switch $prompt
        case Yes
					pw_CLICommand clear
			  case No '*'
					set prompt ""
      end

			if [ -z "$prompt" ]
				pw_CLICommand menu
				return 0
      end

		# No arguments
    case open Open

		# Show dmenu with the controls
			if [ -z "$OPPSTATUS2" ]
				set mpd ':'"$OPPSTATUS"'::seek:setvol:single:random:repeat:consume:clear:update:shuffle:crossfade'

			else
				set mpd ':'"$OPPSTATUS:$OPPSTATUS2"'::seek:setvol:single:random:repeat:consume:clear:update:shuffle:crossfade'
      end

			if [ -z "$mpc_file" ]
				set DMENU_TITLE "$NOTIFYSEND_STATUS Stopped"

			else
				set DMENU_TITLE "$NOTIFYSEND_STATUS "'"'"$title"'"'" by $artist"
      end

			set -g prompt "$(printf '%s\n' "$mpd" | tr ':' '\n' | pw_SpawnMenu $DMENU_TITLE)"
			pw_UserSelection "$prompt"
			if [ -z "$prompt" ]
				exit 0
			else
				pw_MenuOptions Open
    end
  end
end

function pw_Print
	pw_Refresh
  
	switch $FORMATCLI
    case TRUE
			set title "$titlesave"
			set artist "$artistsave"
  end

	# Trim leading space and output the captured input arguments
	set input_arguments (string trim "$argv")
	set -g output_text $(echo "$input_arguments" | awk -v titlevar="$title" -v artistvar="$artist" -v albumvar="$album" -v datevar="$unprocesseddate" -v datepvar="$date" -v statevar="$state" -v stateiconvar="$NOTIFYSEND_STATUS" -v songidvar="$songid" -v filenamevar="$mpc_file" -v dirvar="$filename" '{
	 gsub(/%title%/, titlevar);
	  gsub(/%artist%/, artistvar);
	  gsub(/%album%/, albumvar);
	  gsub(/%date%/, datevar);
	  gsub(/%datep%/, datepvar);
	  gsub(/%state%/, statevar);
	  gsub(/%stateicon%/, stateiconvar);
	  gsub(/%songid%/, songidvar);
	  gsub(/%filename%/, filenamevar);
	  gsub(/%dir%/, dirvar);
	  print;
	}')
	echo "$output_text"
end

# CLI actions
function pw_CLICommand
	pw_Refresh
	switch $argv[1]
    case help 
      pw_Help

    case pause play prev previous backward stop next forward
			set theinput3 $argv[1]
			set CLI True
			pw_UserSelection "$theinput3"

    case menu
      pw_MenuOptions open

    case daemon 
      echo "Periwinkle's Daemon mode is unavailable on Fish."
      exit 1

    case clear update shuffle playlist
			if [ -z "$argv[2]" ]
				pw_MPDCommandButFiltered "$argv";
			else
				pw_Error ManyArguments
      end

    case add rm find save setvol list crossfade single random consume repeat delete direct
			# This is a temporary fix to make the strings parse correctly.
			# Ideally I'd want to edit "pw_MPDCommandButFiltered" directly to make it correct

			if [ "$argv[1]" = "direct" ]
				pw_MPDCommandButFiltered "$argv[2]" "$argv[3]" "$argv[4]" "$argv[5]"
      else if [ -n "$argv[2]" ]
				pw_MPDCommandButFiltered "$argv[1]" "$argv[2]" "$argv[3]" "$argv[4]" "$argv[5]"
			else
				pw_Error FewArguments
      end

    case seek
			if [ -n "$argv[3]" ]
				pw_Error ManyArguments
      end

			if [ -z "$songid" ]
				pw_Error PlaylistClear "$argv[1]"
      end

			if [ -n "$argv[2]" ]
        pw_CheckNumber inRange "$argv[2]" -1 2147483648
				pw_MPDCommandButFiltered seek "$songid" "$argv[2]"
			else
				pw_Error FewArguments
      end

    case format print
			set -g FORMATCLI "TRUE"
      set -l new_argv
      for arg in $argv[2..-1]
        set new_argv $new_argv $arg
      end
      set argv $new_argv
			pw_Print "$argv"

    case clearpreviews
			rm "$Directory_AlbumCover"/*.png

    case statsfornerds
			pw_HashSongName
			pw_SetAlbumCover
			echo 'Output: '
			echo "$stats"
			echo
			echo 'Preview Dir: '"$Directory_AlbumCover"
			echo 'Filename: '"$filename"
			echo 'Preview Name: '"$previewname"
			echo ""
			echo 'Title: '"$title"
			echo 'Artist: '"$artist"
			echo 'Album: '"$album"
			echo 'Date: '"$date"
			echo
			echo 'Hash: '"$UseHash"
			echo "DMENU SETTINGS: " "$Bar_Position" "$DMENU_TITLE" "$Bar_Font" "$Color_Background" "$Color_Foreground" "$Color_SelectedBackground" "$Color_SelectedForeground"

    case console 
      nc "$MPD_Host" "$MPD_Port"
		
    case info 
      pw_AboutProgram
		
    case ""
      begin
        pw_SpawnNotification action
      end
		
    case '*' 
      pw_Error UnknownCommand "$argv[1]"
  end
end

pw_FillInTheBlanks

set pw_DependencyList "nc awk notify-send dmenu ffmpeg"

set pw_DependencyListLen (string length $pw_DependencyList)

set pw_DependencyListLen (math $pw_DependencyListLen + 2)

# Initialize index
set pw_PositionedIn 1

# Iterate over each character in the string to find the missing dependencies.
while [ "$pw_PositionedIn" -lt "$pw_DependencyListLen" ]
	set pw_CurrentChar "$(printf "%s\n" "$pw_DependencyList\n" | cut -c $pw_PositionedIn)"
    set pw_PositionedIn (math $pw_PositionedIn + 1)

	if [ "$pw_CurrentChar" = " " ] || [ $pw_PositionedIn -eq $pw_DependencyListLen ]
		for cmd in $pw_AuxiliarAppend
    		if ! command -v "$cmd" > /dev/null 2>&1
				pw_MissingDependency
        end
    end
		set pw_AuxiliarAppend ""
	else
		set pw_AuxiliarAppend "$pw_AuxiliarAppend""$pw_CurrentChar"
  end

end

switch $Notify_FillEmptyTags
  case true
	  set FORMATCLI "TRUE"
end

switch $Notify_ExtraButtons
  case true
	  set NEWNOTIFBEHAVIOR 0
  case false
	  set NEWNOTIFBEHAVIOR 1
end

# Checks if MPD_Port is a valid number that IS an integer and NOT a string
pw_CheckNumber inRange $MPD_Port 1 65535
pw_CheckNumber isPositive "$Notify_Timeout"

# Checks if Notify_Timeout is a valid number that is NOT a string, but independently if it's an integer

if [ ! -d "$Directory_AlbumCover" ]
	mkdir -v "$Directory_AlbumCover"
end

# The config checking routines were made by ChatGPT. Thank you so much.

# Convert the seconds to milliseconds in the Notify_Timeout variable
set Notify_Timeout "$(awk "BEGIN { printf(\"%.0f\", $Notify_Timeout * 1000) }" | awk '{sub(/%$/,"")}1')"

pw_ReloadMetadata All

pw_Refresh

# Fetch some stuff, better not change this
set mpc_file "$(echo "$stats" | awk -F ': ' '/^file:/ {print $2}' | awk '{$1=$1};1')"
set filename "$Directory_MusicFolder"'/'"(string replace "*:" "" -- $mpc_file)"

switch $Bar_Position
  case top Top
    set Bar_Position "-f"
  case '*'
	  set Bar_Position "-b"
end

trap exit INT
pw_CLICommand $argv
