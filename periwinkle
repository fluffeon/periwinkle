#!/bin/bash

# Check if the necessary dependencies are installed
function whichone() {
	case $cmd in
		"notify-send")
			echo "Error: 'notify-send' (libnotify) is required but not found. Please install it."
			exit 1
		;;
		"nc")
			echo "Error: 'nc' (openbsd-netcat or gnu-netcat) is required but not found. Please install it."
			exit 1
		;;
		"awk")
			echo "Error: 'awk' is required but not found. Please install it."
			exit 1
		;;
		"sed")
			echo "Error: 'sed' is required but not found. Please install it."
			exit 1
		;;
		"grep")
			echo "Error: 'grep' is required but not found. Please install it."
			;;
		"dmenu")
			echo "Error: 'dmenu' is required but not found. Please install it."
                        exit 1
		;;
	"ffmpeg")
		echo "Error: 'ffmpeg' is required but not found. Please install it."
		;;
	esac
}

dependencies=("sed" "nc" "awk" "notify-send" "dmenu" "ffmpeg")

for cmd in "${dependencies[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
	whichone
    fi
done

# Make the config file if it's not there already
function mkconfig() {
	echo '# This is the config file for Periwinkle

# MPD SETTINGS
#
# Self-explanatory, you can set your MPD host here.
# Usually the default will work but you can make it point to a custom URL.
MPD_HOST=localhost
MPD_PORT=6600
MPD_MUSICDIR='$HOME'/Music

# DMENU COLORS
#
# In dwm, usually the following equivalents for dmenu coloring are:
# DMENU_FONT = dmenufont
# DMENUCOL_BG = col_gray1
# DMENUCOL_FG = col_gray3
# DMENUCOL_SELECTBG = col_gray4
# DMENUCOL_SELECTFG = col_cyan
DMENU_FONT=Terminus:size=10
DMENUCOL_BG=#2A2A2A
DMENUCOL_FG=#ECECEC	
DMENUCOL_SELECTBG=#000000
DMENUCOL_SELECTFG=#70C0BA

# PREVIEW SETTINGS
#
# Choose where to save the image previews
PREVIEWDIR='$HOME'/periwinkle

# NOTIFICATION SETTINGS
#
# Notify timeout in seconds
TIMEOUT=3

# PREVIEW SETTINGS
# 
# Choose the hash that you would like to use to save the image previews
# This is useful to keep every single album unique.
# For example, if you had Weezer self-titled albums with the same album name in their metadata, it should be able to differentiate them to show the correct album cover because they have a different metadata for the year and artist. If you have proper metadata for every album then it should work as expected
#
# Options: 
# none | md5 | sha256 | sha512
# The default is sha256
USEHASH=sha256'
}

# Function to check if a value is an integer
is_integer() {
  [[ "$1" =~ ^[0-9]+$ ]]
}

# Function to check if the integer is within the range 0-9999
is_valid_integer() {
  local num=$1
  is_integer "$num" && (( num >= 0 && num <= 9999 ))
}

checknumbers() {
# Read input and validate it until a valid integer in the range 0-9999 is provided
while true; do
  input=$1

  if is_valid_integer "$input"; then
    # Set the variable with the validated integer
    integer_variable="$input"
    break
  else
    echo "Error: '"$input"' is not a valid integer"
    exit 1
  fi
done
}

if [ ! -f "$HOME/.config/periwinkle/config" ]; then
	mkdir $HOME/.config/periwinkle > /dev/null 2>&1
	$(mkconfig > $HOME/.config/periwinkle/config 2>&1)	
	echo "Hello! It looks like it's your first time running Periwinkle."
	echo "I've went ahead and created a config file for you at:"
	echo $HOME'/.config/periwinkle'
	echo -n
	echo "You can tinker with the settings of the program if you'd like."
	echo 'Enjoy! ^w^'
fi



# This whole section is dedicated to setting up the config file.

eliminate_comments() {
    local input_file="$1"
    local the_output
    the_output=$(awk '!/^[[:space:]]*(#|$)/' "$input_file")
    echo "$the_output"
}

# Call the function and store the output in a Bash variable
$(eliminate_comments "$HOME/.config/periwinkle/config" > /tmp/clean_output.txt)

more_config() {
    # Specify the desired environment variables here (space-separated list)
    designated_variables="MPD_HOST MPD_PORT MPD_MUSICDIR PREVIEWDIR DMENU_FONT DMENUCOL_BG DMENUCOL_FG DMENUCOL_SELECTBG DMENUCOL_SELECTFG TIMEOUT USEHASH"

    # Use awk to extract the desired environment variables and set them as Bash variables
    while read -r line; do
        variable_name=$(echo "$line" | awk -F= '{print $1}')
        if [[ $designated_variables =~ $variable_name ]]; then
	echo $line
            export "$line"
        fi
done < "/tmp/clean_output.txt" 
}

# Call the function to set the user configs
more_config > /dev/null 2>&1 
rm /tmp/clean_output.txt
checknumbers $MPD_PORT
checknumbers $TIMEOUT

if [ ! -d "$PREVIEWDIR" ]; then
	mkdir -v $PREVIEWDIR
fi

# Convert the seconds to milliseconds in the Timeout variable
TIMEOUT=$(awk "BEGIN { printf(\"%.0f\", $TIMEOUT * 1000) }" | awk '{sub(/%$/,"")}1')

# Clean the stinky output
function cleanoutput() {
sed "/^OK.*$/d"
}

function help()
{
	echo "Periwinkle - The cutest MPD client"
	echo ""
	echo "This is a CLI and also a semi-GUI client that can"
	echo "be integrated into a DWM desktop by the use of"
	echo "dunst and dmenu, if you'd like."
	echo ""
	echo "Usage: periwinkle <command> [<arguments> <more args>]"
	echo
	echo "Commands"
	echo "	pause - Toggles between pause and play"
	echo "	play - Play the current song"
	echo "	stop - Stops the queue completely"
	echo "	prev, previous - Goes to the previous song on the queue"
	echo "	next, forward - Goes to the next song on the queue"
	echo ""
	echo "	menu - Shows the dmenu prompt directly"
	echo "	notify - Only shows a notification without actions" 
	echo ""
	echo "Debug commands"
	echo "	statsfornerds - Shows some environment variables related to Periwinkle"
	echo "	direct - Interacts with the MPD server directly (advanced)"
	echo ""
	echo "For now this client is a bit basic and stuff, but"
	echo "I'm gonna keep developing it and it will have"
	echo "more features in the future."
}

function programversion() {
	echo "Periwinkle - The cutest MPD client"
	echo "Version:"
	echo ""
	echo "Maintained by flookerton"
	echo ""
	echo "Contributors: ChatGPT, Barrucadu"
}

function error() {
    echo "Error: $* is not a known command >.<"
}

# Function to send commands to MPD which is netcat-agnostic
function mpdcom {
	echo -e "$1\nclose" | nc "$MPD_HOST" "$MPD_PORT";
}

# Save the output to a variable so it isn't called everytime, improving performance
function currentsong() {
	stats="$(mpdcom currentsong | tr -d '\r')"
	mpc_file="$(echo "$stats" | awk -F ': ' '/^file:/ {print $2}' | awk '{$1=$1};1')"
	filename=$MPD_MUSICDIR/${mpc_file##*:}
}

function setmetadata() {
	title=$(echo $stats | grep -oP '(?<=Title:\s).*?(?=\s(?:Title:|Album:|Track:|Date:|Genre:|Disc:|Time:|duration:|Pos:|Id:|$))')
	artist="$(echo "$stats" | awk -F ': ' '/^Artist:/ {print $2}' | awk '{$1=$1};1')"
	album=$(echo $stats | grep -oP '(?<=Album:\s).*?(?=\s(?:Title:|Album:|Track:|Date:|Genre:|Disc:|Time:|duration:|Pos:|Id:|$))')
	date=$(echo $stats | grep -oP '(?<=Date:\s).*?(?=\s(?:Title:|Album:|Track:|Date:|Genre:|Disc:|Time:|duration:|Pos:|Id:|$))')	

	if [ -z "$date" ]; then
		date=""
	else
    		date="($date)"
	fi
}

function ffmpeg_routine() {
	# Comment [ -e "$previewname" ] || if you want the album cover to be constantly overwritten by FFMPEG when it yanks it. Although it makes it very slow and I don't recommend changing it
	# previewname=$PREVIEWDIR/$(echo "$album $date" | sha256sum | cut -d' ' -f1).png
	setpreviewname
	[ -e "$previewname" ] || 
	ffmpeg -y -i "$filename" -an -vf scale=128:128 "$previewname" > /dev/null 2>&1
}

# Settings
#MPDMUSIC_DIR="$HOME/Music"
# PREVIEWDIR="$HOME/ncmpcpp/previews"

# Fetch some stuff, better not change this
mpc_file="$(echo "$stats" | awk -F ': ' '/^file:/ {print $2}' | awk '{$1=$1};1')"
filename=$MPD_MUSICDIR/${mpc_file##*:}
dmenu="dmenu -i -p "mpd:" -fn $DMENU_FONT -nb $DMENUCOL_BG -nf $DMENUCOL_FG -sb $DMENUCOL_SELECTBG -sf $DMENUCOL_SELECTFG"

function setpreviewname() {
case $USEHASH in
	"none")
	previewname=$PREVIEWDIR/$(echo $album $date).png
	;;
	"md5")
	previewname=$PREVIEWDIR/$(echo "$album $date" | md5sum | cut -d' ' -f1).png
	;;
	"sha512")
	previewname=$PREVIEWDIR/$(echo "$album $date" | sha512sum | cut -d' ' -f1).png
	;;
	"sha256" | "" | *)
	previewname=$PREVIEWDIR/$(echo "$album $date" | sha256sum | cut -d' ' -f1).png
	;;	
esac
}

function mpdfunc()
{
    arglist="$1"
     
    [ "$2" != "" ] &&                   arglist="$arglist "$2""
    
    [ "$3" != "" ] && [ "$4" = "" ]  && arglist="$arglist \"$3\""
    
    [ "$3" != "" ] && [ "$4" != "" ] && arglist="$arglist $3 \"$4\""

    [ "$1" = "add" ] || [ "$1" = "save" ] || [ "$1" = "rm" ] && arglist="$1 \"$2\""
    
    mpdcom "$arglist" | cleanoutput
}

function notifselect() { 
# Execute the desired action
case $prompt in
    "")
	$(mpdcom previous) > /dev/null 2>&1
	currentsong
	setmetadata
	ffmpeg_routine
	if [ "$daemonmode" = "true" ]; then
		rm /tmp/dmenu_output.txt
		dmenum &
	fi

	if [ -s /tmp/dmenu_output.txt ]; then
		dmenu_condition=$(cat /tmp/dmenu_output.txt)
		dmenum
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	else
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	fi
        ;;
    "")
	$(mpdcom pause) > /dev/null 2>&1
	currentsong
	setmetadata
	ffmpeg_routine
	if [ "$daemonmode" = "true" ]; then
		rm /tmp/dmenu_output.txt
		dmenum
	fi

	if [ -s /tmp/dmenu_output.txt ]; then
		dmenu_condition=$(cat /tmp/dmenu_output.txt)
		dmenum
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	else
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	fi	
	;;
    "")
	$(mpdcom play) > /dev/null 2>&1
	currentsong
	setmetadata
	ffmpeg_routine
	if [ "$daemonmode" = "true" ]; then
		rm /tmp/dmenu_output.txt
		dmenum
	fi

	if [ -s /tmp/dmenu_output.txt ]; then
		dmenu_condition=$(cat /tmp/dmenu_output.txt)
		dmenum
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	else
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	fi
	;;
    "")
	$(mpdcom stop) > /dev/null 2>&1
	if [ "$daemonmode" = "true" ]; then
		rm /tmp/dmenu_output.txt
		dmenum
	fi

	if [ -s /tmp/dmenu_output.txt ]; then
		dmenu_condition=$(cat /tmp/dmenu_output.txt)
		dmenum
		notify-send -t $TIMEOUT -u low -r 27072 " Stopped" --action "Open=Menu" &
	else
		notify-send -t $TIMEOUT -u low -r 27072 " Stopped" --action "Open=Menu" &
	fi
	;;
    "")
	$(mpdcom next) > /dev/null 2>&1
	currentsong
	setmetadata
	ffmpeg_routine
	if [ "$daemonmode" = "true" ]; then
		rm /tmp/dmenu_output.txt
		dmenum
	fi

	if [ -s /tmp/dmenu_output.txt ]; then
		dmenu_condition=$(cat /tmp/dmenu_output.txt)
		dmenum
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	else
		notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	fi
	;;
    "$artist - $title")
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &
	;;
    *)
        echo -n
        ;;
esac
}

# Menu
function menunotif() {
currentsong
setmetadata
ffmpeg_routine
if [ -z "$title" ]; then
	(notify-send -t $TIMEOUT -u low -r 27072 " Stopped" --action "Open=Menu" > /tmp/dmenu_output.txt)
else
	(notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" --action "Open=Menu" > /tmp/dmenu_output.txt)
fi

if [ -s /tmp/dmenu_output.txt ]; then
	dmenu_condition=$(cat /tmp/dmenu_output.txt)
	dmenum
fi

# Clean up the temporary file
rm /tmp/dmenu_output.txt
}

function menunotif_daemon() {
currentsong
setmetadata
ffmpeg_routine
if [ -z "$title" ]; then
	(notify-send -t $TIMEOUT -u low -r 27072 " Stopped" --action "Open=Menu" > /tmp/dmenu_output_daemon.txt)
else
	(notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" --action "Open=Menu" > /tmp/dmenu_output_daemon.txt)
fi

if [ -s /tmp/dmenu_output_daemon.txt ]; then
	pkill -9 notify-send
	dmenu_condition=$(cat /tmp/dmenu_output_daemon.txt)
	dmenum
fi

# Clean up the temporary file
rm /tmp/dmenu_output_daemon.txt
}

function dmenum() {

# MPD Controls
mpd=("" "" "" "" "" "$artist - $title")

# Show dmenu with the controls
if [ -z "$dmenu_condition" ]; then
	echo -n
else
	prompt=$(printf '%s\n' "${mpd[@]}" | $dmenu)
fi

notifselect

}

function daemonize() {		
echo "You're now running Periwinkle as a daemon!"
echo "The purpose of this feature is to make it so that you get MPD notifications"
echo "even when you're not running it."
echo ""
echo "This feature is still experimental, so please beware of anything that might happen"
daemonmode=true
currentsong
setmetadata
ffmpeg_routine

while true; do
	currentsong
	setmetadata
	currentsong_daemon="$title"

	if [ "$currentsong_daemon" != "$previoussong_daemon" ]; then
		currentsong
		setmetadata
		ffmpeg_routine
		menunotif_daemon
		previoussong_daemon="$currentsong_daemon"
    	fi

# Get the number of processes for the given command
num_processes=$(ps -e -o cmd | grep "notify_send" | wc -l)

# Check if the number of processes is greater than 10
if [ $num_processes -gt 10 ]; then
  # Kill all the processes of the given command
  pkill "notify_send"
  echo "Killed all processes of 'notify_send'."
else
  echo "No action required. 'notify_send' has $num_processes processes."
fi

	sleep 1
done

}



# CLI actions
case $1 in
"help")
        help;;
"pause")
	prompt=""
	notifselect
	currentsong
	setmetadata
	ffmpeg_routine
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &;;
"play")
	prompt=""
	notifselect
	currentsong
	setmetadata
	ffmpeg_routine
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &;;
"prev" | "previous" | "backward")
	prompt=""
	notifselect
	currentsong
	setmetadata
	ffmpeg_routine
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &;;
"'stop'")
	prompt=""
	notifselect
	currentsong
	setmetadata
	ffmpeg_routine
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &;;
"next" | "forward")
	prompt=""
	notifselect
	currentsong
	setmetadata
	ffmpeg_routine
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &;;
"menu")
	$(echo Open > /tmp/dmenu_output.txt)
	currentsong
	setmetadata
	ffmpeg_routine
	dmenu_condition=Open
	if [ -s /tmp/dmenu_output.txt ]; then
		dmenu_condition=$(cat /tmp/dmenu_output.txt)
		dmenum
		rm /tmp/dmenu_output.txt
	fi
	;;
"notify")
	currentsong
	setmetadata
	ffmpeg_routine
	notify-send -t $TIMEOUT -u low -r 27072 " $title" "$artist \n$album $date" -i "$previewname" &;;
"direct")
	mpdcom $2;;
"daemon")
	daemonize;;
"clear" | "update" | "list" | "delete" | "shuffle" | "crossfade")
	mpdfunc $*;;
"config")
	if [ $2 != "reset" ]; then
		echo "Error: Wrong arguments for this command"
	elif [ $2 = "reset" ]; then
		echo "Restoring Periwinkle's configurations to their defaults..."
		rm $HOME/.config/periwinkle/config
		$(mkconfig > $HOME/.config/periwinkle/config 2>&1)
		echo "Done!"
	else
		echo 'Location: '$HOME/,config/periwinkle/config
		echo ""
		cat $HOME/.config/periwinkle/config
	fi
;;
"add" | "rm" | "find" | "save" | "setvol")
	# This is a temporary fix to make the strings parse correctly.
	# Ideally I'd want to edit "mpdfunc" directly to make it correct
	if [ -n $3 ]; then
		CORRECT_INPUT3=$3
	fi

	if [ -n $4 ]; then
		CORRECT_INPUT4=$4
	fi

	if [ -n "$2" ]; then
		CORRECT_INPUT2="$2"
		mpdfunc $1 "$CORRECT_INPUT2" "$CORRECT_INPUT3" "$CORRECT_INPUT4"
	else
		echo "Error: Too few arguments"
		exit 1
	fi	
	;;
"statsfornerds")
	setpreviewname
	currentsong
	setmetadata
	ffmpeg_routine
	echo 'Output: '
	echo $stats
	echo
	echo 'Preview Dir: '"$PREVIEWDIR"
	echo 'Filename: '"$filename"
	echo 'Preview Name: '"$previewname"
	echo ""
	echo 'Title: '"$title"
	echo 'Artist: '"$artist"
	echo 'Album: '"$album"
	echo 'Date: '"$date"
	echo
	echo 'Hash: '"$USEHASH"
;;
"version")
	programversion
	;;
"")
        menunotif;;
 
    *)
        error $*
	exit 1;;
esac
