#!/bin/bash
#    Periwinkle - A MPD client with tight integration with dmenu and libnotify.
#    Copyright (C) 2023 flookerton
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

echo "WARNING: This branch of Periwinkle has been deprecated, please use the lite version from now on."
function error() {
case $1 in
"unknown")
	echo "Error: '"$input"' is not a known command >.<"
	exit 1;;
	
"invint")
	echo "Error: '"$input"' is not a valid integer -w-"
	exit 1;;

"invnum")
	echo "Error: '"$input"' is not a valid number -w-"
	exit 1;;

"fewargs")
	echo "Error: Not enough arguments... ;w;"
	exit 1;;

"manyargs")
	echo "Error: T-That's too many arguments!! >w<"
	exit 1;;

"wrongargs")
	echo "Error: Wrong arguments for this command... :<"
	exit 1;;
"stopped")
	echo "Error: You can't "$input" if you have no songs in your queue, silly! .w."
	exit 1;;
"" | *)
	echo "Error: Something went wrong... o.O"
	exit 1;;
esac
}

# Check if the necessary dependencies are installed
function whichone() {
	case $cmd in
		"notify-send")
			echo "Dependency missing: 'notify-send' (libnotify) is required but not found. Please install it."
			exit 1;;

		"nc")
			echo "Dependency missing: 'nc' (openbsd-netcat or gnu-netcat) is required but not found. Please install it."
			exit 1;;

		"awk")
			echo "Dependency missing: 'awk' is required but not found. Please install it."
			exit 1;;
		"dmenu")
			echo "Dependency missing: 'dmenu' is required but not found. Please install it."
                        exit 1;;

		"ffmpeg")
			echo "Dependency missing: 'ffmpeg' is required but not found. Please install it."
			exit 1;;
	esac
}

dependencies=("nc" "awk" "notify-send" "dmenu" "ffmpeg")

for cmd in "${dependencies[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
	whichone
    fi
done

# This whole section is dedicated to setting up the config file.

# Make the config file if it's not there already
function mkconfig() {
	echo '# This is the config file for Periwinkle

# MPD SETTINGS
#
# Self-explanatory, you can set your MPD host here.
# Usually the default will work but you can make it point to a custom URL.
MPD_HOST=localhost
MPD_PORT=6600
MPD_MUSICDIR='$HOME'/Music

# DMENU COLORS
#
# In dwm, usually the following equivalents for dmenu coloring are:
# DMENU_FONT = dmenufont
# DMENUCOL_BG = col_gray1
# DMENUCOL_FG = col_gray3
# DMENUCOL_SELECTBG = col_gray4
# DMENUCOL_SELECTFG = col_cyan
DMENU_FONT=Terminus:size=10
DMENUCOL_BG=#2A2A2A
DMENUCOL_FG=#ECECEC	
DMENUCOL_SELECTBG=#000000
DMENUCOL_SELECTFG=#70C0BA

# PREVIEW SETTINGS
#
# Choose where to save the image previews
PREVIEWDIR='$HOME'/periwinkle

# NOTIFICATION SETTINGS
#
# Notify timeout in seconds
# Set 0 for no timeout
TIMEOUT=3

# PREVIEW SETTINGS
# 
# Choose the hash that you would like to use to save the image previews
# This is useful to keep every single album unique.
# For example, if you had Weezer self-titled albums with the same album name in their metadata, it should be able to differentiate them to show the correct album cover because they have a different metadata for the year and artist. If you have proper metadata for every album then it should work as expected
#
# Options: 
# none | md5 | sha256 | sha512 | base64
# The default is sha256
USEHASH=sha256'
}

# Function to check if a value is a number
function is_positive_number() {
  local input="$1"
  if [[ $input =~ ^[0-9]+([.][0-9]+)?$ ]] && (( $(awk 'BEGIN { print '"$input"' >= 0 }') )); then
    return 0 # It's a positive number
  else
    return 1 # It's not a positive number or it contains non-numeric characters
  fi
}

is_integer() {
[[ "$input" =~ ^[0-9]+$ ]]
}

# Function to check if the integer is within the desired range
is_valid_integer() {
  local num="$input"
  is_integer "$num" && (( num >= $MINIMUMVAL && num <= $MAXIMUMVAL ))
}

checknumbers() {
# Read input and validate it until a valid integer in the range is provided
# while true; do
case $2 in
"integer")
	input=$1

	if is_valid_integer "$input"; then
	# Set the variable with the validated integer
		echo -n
	else
		input=$1 error invint
	fi;;
"decimal")
	input=$1
	if is_positive_number "$input"; then
		echo -n
	else
		input=$1 error invnum
	fi;;
*)
	echo $1
	echo "DEBUG INFO: Invalid arguments for this function"
	echo "If this gets outputted onto you, please open a issue about it"
	error;;
esac
# done
}

notifysendthing() {
case $1 in
	"action")
		currentsong
		setmetadata
		ffmpeg_routine
		CONDITIONOPEN=$(notify-send -t $TIMEOUT -u low -r 27072 "$(echo $NOTIFYSEND_STATUS) $(echo $NOTIFYSEND_TITLE)" "$(echo $NOTIFYSEND_SUBTITLE)" -i "$previewname" --action "Open=Menu")
	if [ -z "$CONDITIONOPEN" ]; then
		return 0
	else
	dmenum $CONDITIONOPEN
	fi
	;;

"daemon")	
		CONDITIONOPEN=$(notify-send -t $TIMEOUT -u low -r 27072 "$(echo $NOTIFYSEND_STATUS) $(echo $NOTIFYSEND_TITLE)" "$(echo $NOTIFYSEND_SUBTITLE)" -i "$previewname" --action "Open=Menu")
	if [ -z $CONDITIONOPEN ]; then
		return 0
	fi

	if [ -s /tmp/pw_daemonmode ]; then
		CONDITIONOPEN=daemon
		dmenum $CONDITIONOPEN
	fi
	;;

"welcome") notify-send -t 7000 -u normal "$(echo 'Welcome to Periwinkle!')" "$(echo "It looks like it's your first time running Periwinkle. I've went ahead and created a config file for you at:\n\n$HOME/.config/periwinkle")";;

*) notify-send -t $TIMEOUT -u low -r 27072 "$(echo $NOTIFYSEND_STATUS) $(echo $NOTIFYSEND_TITLE)" "$(echo $NOTIFYSEND_SUBTITLE)" -i "$previewname";;
esac
}

function setpreviewname() {
case $USEHASH in
	"none")
	previewname="$PREVIEWDIR"/"$(echo $album $date)".png
	;;
	"md5")
	previewname="$PREVIEWDIR"/"$(echo "$album $date" | md5sum | cut -d' ' -f1)".png
	;;
	"base64")
	previewname="$PREVIEWDIR"/"$(echo "$album $date" | base64 | cut -d' ' -f1)".png
	;;
	"sha512")
	previewname="$PREVIEWDIR"/"$(echo "$album $date" | sha512sum | cut -d' ' -f1)".png
	;;
	"sha256" | "" | *)
	previewname="$PREVIEWDIR"/"$(echo "$album $date" | sha256sum | cut -d' ' -f1)".png
	;;	
esac
}

if [ ! -f "$HOME/.config/periwinkle/config" ]; then
	mkdir $HOME/.config/periwinkle > /dev/null 2>&1
	$(mkconfig > $HOME/.config/periwinkle/config 2>&1)	
	notifysendthing welcome &
fi

eliminate_comments() {
    local input_file="$1"
    local the_output
    the_output=$(awk '!/^[[:space:]]*(#|$)/' "$input_file")
    echo "$the_output"
}

# Call the function and store the output in a Bash variable
$(eliminate_comments "$HOME/.config/periwinkle/config" > /tmp/clean_output.txt)

more_config() {
    # Specify the desired environment variables here (space-separated list)
    designated_variables="MPD_HOST MPD_PORT MPD_MUSICDIR PREVIEWDIR DMENU_FONT DMENUCOL_BG DMENUCOL_FG DMENUCOL_SELECTBG DMENUCOL_SELECTFG TIMEOUT USEHASH"

    # Use awk to extract the desired environment variables and set them as Bash variables
    while read -r line; do
        variable_name=$(echo "$line" | awk -F= '{print $1}')
        if [[ $designated_variables =~ $variable_name ]]; then
	echo $line
            export "$line"
        fi
done < "/tmp/clean_output.txt" 
}

# Call the function to set the user configs
more_config > /dev/null 2>&1
rm /tmp/clean_output.txt

# Checks if MPD_PORT is a valid number that IS an integer and NOT a string
MINIMUMVAL=1 MAXIMUMVAL=65535 checknumbers "$MPD_PORT" integer
checknumbers "$TIMEOUT" decimal

# Checks if TIMEOUT is a valid number that is NOT a string, but independently if it's an integer

if [ ! -d "$PREVIEWDIR" ]; then
	mkdir -v "$PREVIEWDIR"
fi

# The config checking routines were made by ChatGPT. Thank you so much.

# Convert the seconds to milliseconds in the TIMEOUT variable
TIMEOUT=$(awk "BEGIN { printf(\"%.0f\", $TIMEOUT * 1000) }" | awk '{sub(/%$/,"")}1')

# Clean the stinky output
function cleanoutput() {
awk '!/^OK.*$/'
}

function help() {
echo "Periwinkle - The cutest MPD client

This is a CLI and also a semi-GUI client that can
be integrated into a DWM desktop by the use of
dunst and dmenu, if you'd like.

Usage: periwinkle [<command> <arguments> ... <more args>]

Fetch Commands
	add <file> - Adds a song from the music dir to the playlist
	delete <int song> - Removes a song from the playlist
	list <metadata arg1> [<metadata arg2> <search term>] - Fetches a list of songs based on the metadata input by the user

Playback Commands
	pause - Toggles between pause and play
	play - Play the current song
	stop - Stops the playlist completely
	prev, previous - Goes to the previous song on the queue
	next, forward - Goes to the next song on the queue
	setvol <0 - 100> - Sets the volume
	seek <num> - Seeks to a certain point of the song
	single <0-1 or oneshot> - Sets single mode
	random <0-1> - Sets random mode
	repeat <0-1> - Sets repeat mode
	consume <0-1> - Sets consume mode

Playlist Commands
	crossfade <int> - Sets a crossfade between songs
	shuffle - Shuffles the playlist
	save <string playlist name> - Saves the playlist as a file
	rm <string playlist name> - Deletes a saved playlist
	playlist - Shows the current playlist and song IDs
	delete - Removes a song from the current playlist

Database Commands
	update - Updates the MPD database

Periwinkle Commands
	menu - Shows the dmenu prompt directly
	info - Report version of Periwinkle, and licensing information
	config <reset> - Show your config file
	format <%title% %artist% %album% %date% %songid% %state% %stateicon%> - Command that works like mpc's "--format" flag.
	The point of the command above is to echo current song info in a clean manner for other scripts.

Advanced commands
	daemon - Run as a daemon to show song notifications on the background (experimental)
	statsfornerds - Shows some environment variables related to Periwinkle
	console - Pulls an interactive MPD control terminal (advanced)
	direct - Sends commands to MPD without being interactive, useful for scripts

For now this client is a bit basic and stuff, but
I'm gonna keep developing it and it will have
more features in the future."
}

function programinfo() {
	echo "
    Periwinkle - The cutest MPD client
    Version:

    Copyright (C) 2023  flookerton

    Contributors: ChatGPT, Barrucadu

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>."
}

# Function to send commands to MPD which is netcat-agnostic
function mpdcom { echo -e "$1\nclose" | nc "$MPD_HOST" "$MPD_PORT"; }

# Save the output to a variable so it isn't called everytime, improving performance
function currentsong() {
	stats="$(mpdcom currentsong | tr -d '\r')"
	stats2="$(mpdcom status | tr -d '\r')"
	mpc_file="$(echo "$stats" | awk -F ': ' '/^file:/ {print $2}' | awk '{$1=$1};1')"
	filename=$MPD_MUSICDIR/${mpc_file##*:}
}

function setmetadata() {	
	title="$(echo "$stats" | awk -F ': ' '/^Title:/ { sub(/^Title: /, ""); print }')"
	artist="$(echo "$stats" | awk -F ': ' '/^Artist:/ { sub(/^Artist: /, ""); print }')"
	album="$(echo "$stats" | awk -F ': ' '/^Album:/ { sub(/^Album: /, ""); print }')"
	date="$(echo "$stats" | awk -F ': ' '/^Date:/ { sub(/^Date: /, ""); print }')"
	songid="$(echo "$stats2" | awk -F ': ' '/^song:/ { sub(/^song: /, ""); print }')"
	state="$(echo "$stats2" | awk -F ': ' '/^state:/ { sub(/^state: /, ""); print }')"	

	unprocesseddate=$date
	if [ -z "$date" ]; then
		date=""
	else
    		date="($date)"
	fi

	if [ -z "$mpc_file" ]; then
		NOTIFYSEND_TITLE="Stopped"
		NOTIFYSEND_SUBTITLE=""
	else
		NOTIFYSEND_TITLE="$title"
		NOTIFYSEND_SUBTITLE="$(echo "$artist\n$album $date")"
	fi 
	
	if [ "$state" = "stop" ]; then
		NOTIFYSEND_STATUS=""
	elif [ "$state" = "pause" ]; then
		NOTIFYSEND_STATUS=""
	elif [ "$state" = "play" ]; then
		NOTIFYSEND_STATUS=""
	fi
}

function ffmpeg_routine() {	
	setpreviewname
	[ -e "$previewname" ] || 
	ffmpeg -y -i "$filename" -an -vf scale=128:128 "$previewname" > /dev/null 2>&1
}

# Fetch some stuff, better not change this
mpc_file="$(echo "$stats" | awk -F ': ' '/^file:/ {print $2}' | awk '{$1=$1};1')"
filename=$MPD_MUSICDIR/${mpc_file##*:}

dmenuthing() {
dmenu -i -p "$DMENU_TITLE" -fn "$DMENU_FONT" -nb "$DMENUCOL_BG" -nf "$DMENUCOL_FG" -sb "$DMENUCOL_SELECTBG" -sf "$DMENUCOL_SELECTFG"
}

function mpdfunc()
{
    arglist="$1"
     
    [ "$2" != "" ] &&                   arglist="$arglist "$2""
    
    [ "$3" != "" ] && [ "$4" = "" ]  && arglist="$arglist \"$3\""
    
    [ "$3" != "" ] && [ "$4" != "" ] && arglist="$arglist $3 \"$4\""

    [ "$1" = "add" ] || [ "$1" = "save" ] || [ "$1" = "rm" ] && arglist="$1 \"$2\""
    
    mpdcom "$arglist" | cleanoutput
}

function notifselect() { 
# Execute the desired action
case $1 in
    "" | "prev" | "previous" | "backward")
	$(mpdcom previous) > /dev/null 2>&1
	if [ -s /tmp/pw_daemonmode ]; then
		return 0
		
	fi

	notifysendthing action &
	;;
    "" | "pause")
	$(mpdcom pause) > /dev/null 2>&1	
	if [ -s /tmp/pw_daemonmode ]; then
		return 0
	fi
	notifysendthing action &
	;;
    "" | "play")
	$(mpdcom play) > /dev/null 2>&1
	if [ -s /tmp/pw_daemonmode ]; then
		return 0
	fi

	notifysendthing action &;;
    "" | "stop")
	$(mpdcom stop) > /dev/null 2>&1
	if [ -s /tmp/pw_daemonmode ]; then
		return 0
	fi

	notifysendthing action &;;
    "" | "next" | "forward")
	$(mpdcom next) > /dev/null 2>&1
	if [ -s /tmp/pw_daemonmode ]; then
		return 0
	fi

	notifysendthing action &;;
	"seek" | "Seek" | "Volume" | "volume" | "setvol" | "vol" | "Vol" | "CLI" | "cli")
		dmenum $prompt;;
*) prompt=$(echo -n);;
esac
}

function dmenum() {
# Default MPD options
mpd=("" "" "" "" "" "seek" "setvol")

# Different dmenu routines
case $1 in
# Daemon option
"daemon")
currentsong
setmetadata
if [ "$CLI" = "TRUE" ]; then
		exit 0
fi

if [ -z "$mpc_file" ]; then
		DMENU_TITLE="$NOTIFYSEND_STATUS Stopped"
	else
		DMENU_TITLE="$NOTIFYSEND_STATUS $artist - $title"
	fi

# Show dmenu with the controls
if [ -s /tmp/pw_daemonmode ]; then	
	prompt="$(printf '%s\n' "${mpd[@]}" | dmenuthing)"
	notifselect $prompt &
fi

if [ -z "$prompt" ]; then
	return 0
else
	dmenum daemon
fi
;;

# Different commands
"seek" | "Seek")
if [ -z "$2" ]; then
	DMENU_TITLE='Seek to where?'
	prompt=$(echo -n | dmenuthing)
	cli seek $prompt
elif [ -n "$2" ]; then
	theinput2=$2
	cli seek $theinput2
fi;;

"Vol" | "volume" | "Volume" | "setvol" | "vol")
if [ -z "$2" ]; then
	DMENU_TITLE='Set volume (0-100)'
	prompt=$(echo -n | dmenuthing)
	cli setvol $prompt
elif [ -n "$2" ]; then
	theinput2=$2
	cli setvol $theinput2
fi;;

"CLI" | "cli")
DMENU_TITLE='Enter your periwinkle cmd (debugging purposes)'
prompt=$(echo -n | dmenuthing)
cli "$prompt";;

# No arguments
"open" | "Open")

# Show dmenu with the controls
currentsong
setmetadata
if [ -z "$mpc_file" ]; then
	DMENU_TITLE="$NOTIFYSEND_STATUS Stopped"
else
	DMENU_TITLE="$NOTIFYSEND_STATUS $artist - $title"
fi

prompt="$(printf '%s\n' "${mpd[@]}" | dmenuthing)"
notifselect $prompt
if [ -z "$prompt" ]; then
	exit 0
else
	dmenum Open
fi
;;

"" | *) echo "";;
esac
}

function quitdaemon() {
	echo 'Quitting...'
	rm /tmp/pw_daemonmode
	exit 0
}

function daemonize() {		
echo "You're now running Periwinkle as a daemon!"
echo "The purpose of this feature is to make it so that you get MPD notifications"
echo "even when you're not running it."
echo ""
echo "This feature is still experimental, so please beware of anything that might happen"
echo 'Daemon Mode' > /tmp/pw_daemonmode
currentsong
setmetadata
ffmpeg_routine
previousstate="$state"
trap quitdaemon SIGINT

while true; do
	currentsong
	setmetadata
	currentsong_daemon="$title - $artist - $album $date"
	currentstate="$state"

	if [ "$currentsong_daemon" != "$previoussong_daemon" ]; then
		currentsong
		setmetadata
		ffmpeg_routine
		echo 'Song changed to: '"'$title'"' by '"$artist"
		notifysendthing daemon &
		previoussong_daemon="$currentsong_daemon"
    	elif [ "$currentstate" != "$previousstate" ]; then
		currentsong
		setmetadata
		ffmpeg_routine
		echo 'State changed to '"$currentstate"
		notifysendthing daemon &
		previousstate="$currentstate"
	fi
	sleep 0,5
done

}

get_user_confirmation() {
  read -r -p "$1 (y/n): " response
  case "$response" in
    [yY]|[yY][eE][sS]) return 0 ;;
    *) return 1 ;;
  esac
}

resetpericonfig() {
if get_user_confirmation "Do you want to reset Periwinkle's settings to their defaults?";then
	echo "Restoring Periwinkle's configurations to their defaults..."
		rm $HOME/.config/periwinkle/config
		$(mkconfig > $HOME/.config/periwinkle/config 2>&1)
		echo "Done!"
	else
		exit 0
fi
}

# CLI actions
cli() {
case $1 in
"help") help;;
"pause" | "play" | "prev" | "previous" | "backward" | "stop" | "next" | "forward")
	theinput3=$1
	CLI="TRUE"
	notifselect $theinput3 
	currentsong
	setmetadata
	ffmpeg_routine	
;;
"menu")
	currentsong
	setmetadata
	ffmpeg_routine
	dmenum open &;;
"daemon") daemonize;;
"clear" | "update" | "shuffle" | "playlist")
	if [ -z $2 ]; then
		mpdfunc $*;
	else
		error manyargs
	fi
;;
"config")
	if [ $2 != "reset" ]; then
		error wrongargs
	elif [ -n "$3" ]; then
		error manyargs
	elif [ $2 = "reset" ]; then
		resetpericonfig	
	else
		echo 'Location: '"$HOME"'/.config/periwinkle/config'
		echo ""
		cat $HOME/.config/periwinkle/config
	fi
;;
"add" | "rm" | "find" | "save" | "setvol" | "list" | "crossfade" | "single" | "random" | "consume" | "repeat" | "delete" | "direct")
	# This is a temporary fix to make the strings parse correctly.
	# Ideally I'd want to edit "mpdfunc" directly to make it correct
	if [ -n "$2" ]; then
		CORRECT_INPUT2="$2"
	fi

	if [ -n "$3" ]; then
		CORRECT_INPUT3="$3"
	fi

	if [ -n "$4" ]; then
		CORRECT_INPUT4="$4"
	fi

	if [ -n "$5" ]; then
		CORRECT_INPUT5="$5"
	fi

	if [ "$1" = "direct" ]; then
		mpdfunc "$CORRECT_INPUT2" "$CORRECT_INPUT3" "$CORRECT_INPUT4" "$CORRECT_INPUT5"
	elif [ -n "$2" ]; then
		mpdfunc $1 "$CORRECT_INPUT2" "$CORRECT_INPUT3" "$CORRECT_INPUT4" "$CORRECT_INPUT5"
	else
		error fewargs
	fi	
	;;
"seek")
currentsong
setmetadata

if [ -n "$3" ]; then
	error manyargs
fi

if [ -z "$songid" ]; then
	input="$1" error stopped
fi

if [ -n "$2" ]; then
	CORRECT_INPUT2=$2
	MINIMUMVAL=0 MAXIMUMVAL=2147483647 checknumbers "$CORRECT_INPUT2" integer
	mpdfunc seek "$songid" "$CORRECT_INPUT2"
	exit 0
else
	error fewargs
fi;;
"format")
currentsong
setmetadata
command="$*"
shift

input_arguments="$*"

# Trim leading space and output the captured input arguments
input_arguments="${input_arguments# }"
output_text=$(echo "$input_arguments" | awk -v titlevar="$title" -v artistvar="$artist" -v albumvar="$album" -v datevar="$unprocesseddate" -v statevar="$state" -v stateiconvar="$NOTIFYSEND_STATUS" -v songidvar="$songid" '{
 gsub(/%title%/, titlevar);
  gsub(/%artist%/, artistvar);
  gsub(/%album%/, albumvar);
  gsub(/%date%/, datevar);
  gsub(/%state%/, statevar);
  gsub(/%stateicon%/, stateiconvar);
  gsub(/%songid%/, songidvar);
  print;
}')
echo $output_text
;;
"statsfornerds")
	setpreviewname
	currentsong
	setmetadata
	ffmpeg_routine
	echo 'Output: '
	echo $stats
	echo
	echo 'Preview Dir: '"$PREVIEWDIR"
	echo 'Filename: '"$filename"
	echo 'Preview Name: '"$previewname"
	echo ""
	echo 'Title: '"$title"
	echo 'Artist: '"$artist"
	echo 'Album: '"$album"
	echo 'Date: '"$date"
	echo
	echo 'Hash: '"$USEHASH"
;;
"console") nc "$MPD_HOST" "$MPD_PORT";;
"info") programinfo;;
"") notifysendthing action &;; 
*) input="$1" error unknown;;
esac
}

if [ -z "$1" ]; then
	cli
elif [ -n "$1" ]; then
	theinput=$*
	cli $theinput
fi
